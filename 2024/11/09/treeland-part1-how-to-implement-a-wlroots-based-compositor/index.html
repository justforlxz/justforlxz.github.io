<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Treeland Part.1 如何实现一个基于 wlroots 的合成器 | 小竹's blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.1.15"><!-- inject head--><meta name="google-site-verification" content="UA-129024325-1"><meta name="baidu-site-verification" content="49e5979358cb9ca19e5e56fc4adc4a98"><link rel="canonical" href="https://blog.justforlxz.com/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><!-- aplayer--><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><!-- swiper--><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="😀 Treeland 是一个基于 wlroots 和 Qt 的 Wayland 合成器 并且支持多用户共用合成器。 名词概念QtQt（&amp;#x2F;ˈkjuːt&amp;#x2F;，发音同“cute”）是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="小竹's blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.1.15' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }

              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })

              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}

                if (name && keyObj[name]) return

                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
            addEventListenerPjax: (ele, event, fn, option = false) => {
              ele.addEventListener(event, fn, option)
              utils.addGlobalFn('pjax', () => {
                  ele.removeEventListener(event, fn, option)
              })
          },
        }
    })()</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2016-03-24 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.avif'
    },
    copyright: false,
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。","loading":"搜索中..."}},
    aside: {
        sayhello: {
            morning: "✨ 早上好，新的一天开始了",
            noon: "🍲 午餐时间",
            afternoon: "🌞 下午好",
            night: "早点休息",
            goodnight: "晚安 😴",
        },
        sayhello2: ["你可以的","你一定可以的","祝你好运，陌生人"],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: true
    },
    comment: false,
    lightbox: 'mediumZoom',
    post_ai: false,
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","translate":false,"ctrlOriginalMenu":"按住Ctrl+右键可打开浏览器右键菜单"},
    translate: {"translateDelay":0,"defaultEncoding":2},
    lure: {"jump":"404 Not Found","back":"ヾ(≧∇≦*)ゝHey, hey, you fell for it."},
    expire: {"time":30,"position":"top","text_prev":"This article expired ","text_next":" day ago, if the content does not match, please contact the webmaster to update it."},
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: true,
    ai_text: false,
    color: false,
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="小竹's blog" type="application/atom+xml">
</head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- background img--><div id="global_bg"></div><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="solitude  fas fa-wifi"></i><span>朋友圈</span></a></li><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  fas fa-music"></i><span>音乐馆</span></a></li><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>作者</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/2019/">2019<sup>1</sup></a><a href="/tags/k8s/">k8s<sup>3</sup></a><a href="/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4/">实验室<sup>3</sup></a><a href="/tags/CMake-Linux/">CMake Linux<sup>1</sup></a><a href="/tags/C/">C++<sup>8</sup></a><a href="/tags/Linux/">Linux<sup>29</sup></a><a href="/tags/Qt/">Qt<sup>4</sup></a><a href="/tags/CMake/">CMake<sup>1</sup></a><a href="/tags/GTest/">GTest<sup>1</sup></a><a href="/tags/CTest/">CTest<sup>1</sup></a><a href="/tags/Bash/">Bash<sup>1</sup></a><a href="/tags/deepin/">deepin<sup>1</sup></a><a href="/tags/kwin/">kwin<sup>1</sup></a><a href="/tags/CSS/">CSS<sup>3</sup></a><a href="/tags/Next-js/">Next.js<sup>1</sup></a><a href="/tags/Web/">Web<sup>7</sup></a><a href="/tags/JavaScript/">JavaScript<sup>3</sup></a><a href="/tags/parallels-desktop/">parallels desktop<sup>1</sup></a><a href="/tags/linux/">linux<sup>5</sup></a><a href="/tags/Kitty/">Kitty<sup>1</sup></a><a href="/tags/systemd/">systemd<sup>2</sup></a><a href="/tags/Hexo/">Hexo<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/">教程<sup>3</sup></a><a href="/tags/kubernetes/">kubernetes<sup>1</sup></a><a href="/tags/Github-Action/">Github Action<sup>1</sup></a><a href="/tags/evil/">evil<sup>1</sup></a><a href="/tags/%E6%95%B0%E7%BB%84/">数组<sup>3</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/">算法<sup>3</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/">简单<sup>3</sup></a><a href="/tags/vim/">vim<sup>2</sup></a><a href="/tags/dde/">dde<sup>1</sup></a><a href="/tags/go/">go<sup>1</sup></a><a href="/tags/docker/">docker<sup>1</sup></a><a href="/tags/Linux-%E5%A1%AB%E5%9D%91/">Linux 填坑<sup>1</sup></a><a href="/tags/Metal/">Metal<sup>5</sup></a><a href="/tags/GameEngine/">GameEngine<sup>5</sup></a><a href="/tags/%E5%81%A5%E5%BA%B7-%E6%80%9D%E8%80%83/">健康, 思考<sup>1</sup></a><a href="/tags/LNMP/">LNMP<sup>1</sup></a><a href="/tags/Deepin/">Deepin<sup>1</sup></a><a href="/tags/javascript/">javascript<sup>1</sup></a><a href="/tags/jsx/">jsx<sup>1</sup></a><a href="/tags/latex/">latex<sup>1</sup></a><a href="/tags/Game/">Game<sup>1</sup></a><a href="/tags/Unity/">Unity<sup>1</sup></a><a href="/tags/Shader/">Shader<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/">模板<sup>1</sup></a><a href="/tags/neovim/">neovim<sup>1</sup></a><a href="/tags/dap/">dap<sup>1</sup></a><a href="/tags/Program/">Program<sup>1</sup></a><a href="/tags/typescript/">typescript<sup>2</sup></a><a href="/tags/react/">react<sup>1</sup></a><a href="/tags/react-native/">react native<sup>1</sup></a><a href="/tags/dotfile/">dotfile<sup>1</sup></a><a href="/tags/vuex/">vuex<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8/">日常<sup>1</sup></a><a href="/tags/reactnative/">reactnative<sup>1</sup></a><a href="/tags/ios/">ios<sup>1</sup></a><a href="/tags/C-Wayland-%E5%9B%BE%E5%BD%A2%E5%AD%A6/">C++, Wayland, 图形学<sup>1</sup></a><a href="/tags/UOS-Vulkan-%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%BC%80%E5%8F%91/">UOS, Vulkan, 图形学, 开发<sup>1</sup></a><a href="/tags/VS-Code/">VS Code<sup>1</sup></a><a href="/tags/Windows/">Windows<sup>2</sup></a><a href="/tags/Vue/">Vue<sup>4</sup></a><a href="/tags/Wayland/">Wayland<sup>4</sup></a><a href="/tags/Linux-DTK/">Linux DTK<sup>1</sup></a><a href="/tags/Webpack/">Webpack<sup>1</sup></a><a href="/tags/TypeScript/">TypeScript<sup>1</sup></a><a href="/tags/Deep-Learning/">Deep Learning<sup>1</sup></a><a href="/tags/nVidia-Cuda/">nVidia Cuda<sup>1</sup></a><a href="/tags/Deepin-Learning/">Deepin Learning<sup>1</sup></a></div></div><span class="sidebar-menu-item-title">网站信息</span><div class="webinfo"><div class="webinfo-item"><div class="webinfo-item-title"><i class="item-icon solitude fa-solid fa-file-word"></i><div class="item-name">全站字数 :</div></div><div class="item-count">117.1k</div></div></div></div></div><!-- keyboard--><!-- righhtside--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">竹子的碎碎念</span><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">Treeland Part.1 如何实现一个基于 wlroots 的合成器</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="solitude  fas fa-wifi"></i><span>朋友圈</span></a></li><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  fas fa-music"></i><span>音乐馆</span></a></li><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>作者</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude fa-solid fa-dice-d6"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude fa-solid fa-magnifying-glass"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude fa-solid fa-arrow-up"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://file.mkacg.com/misskey/files/d78b4a0e-8dfe-493d-aa49-1f0741f115ec.png" alt="Treeland Part.1 如何实现一个基于 wlroots 的合成器"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Wayland-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tags-name tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>C++, Wayland, 图形学</span></a></div></div></div></div><h1 class="post-title">Treeland Part.1 如何实现一个基于 wlroots 的合成器</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-11-09 00:00:00"><i class="post-meta-icon solitude fas fa-calendar-days"></i><time datetime="2024-11-08T16:00:00.000Z">2024-11-08T16:00:00.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-12-31 15:15:08"><i class="post-meta-icon solitude fa-solid fa-arrows-rotate"></i><time datetime="2024-12-31T07:15:08.125Z">2024-12-31T07:15:08.125Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon solitude fa-solid fa-file-word" title="文章字数"></i><span class="word-count">5.2k</span><span class="post-meta-separator"></span><i class="post-meta-icon solitude fa-solid fa-clock" title="阅读耗时"></i><span>27 min</span></span><span class="post-meta-position" title="作者IP归属地为China"><i class="post-meta-icon solitude fas fa-location-dot"></i><span>China</span></span><a class="post-meta-pv" href="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/" title="文章热度"><i class="post-meta-icon solitude fa-solid fa-fire-flame-curved"></i></a><span class="post-meta-commentcount" title="评论数" onclick="sco.scrollTo('post-comment')"><i class="solitude fa-solid fa-comment"></i><a href="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/#post-comment"></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content article-container"><aside>
😀 Treeland 是一个基于 wlroots 和 Qt 的 Wayland 合成器
并且支持多用户共用合成器。

</aside>

<h2 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h2><h3 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h3><p>Qt（&#x2F;ˈkjuːt&#x2F;，发音同“cute”）是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，例如控制台工具和服务器。</p>
<h3 id="wlroots"><a href="#wlroots" class="headerlink" title="wlroots"></a>wlroots</h3><p>用于构建 <a target="_blank" rel="noopener" href="https://wayland.freedesktop.org/">Wayland</a> 合成器的模块化工具集，简化了约 60,000 行代码的开发工作。</p>
<ul>
<li>提供抽象底层显示和输入的后端，支持 KMS&#x2F;DRM、libinput、Wayland、X11 等，可动态创建和销毁。</li>
<li>实现多种 Wayland 接口，支持协议扩展，促进合成器标准化。</li>
<li>提供通用合成器组件，如物理空间输出管理。</li>
<li>集成 Xwayland 抽象，简化 X11 窗口管理。</li>
<li>提供渲染器抽象，支持简单和自定义渲染需求。</li>
</ul>
<h3 id="seat"><a href="#seat" class="headerlink" title="seat"></a>seat</h3><p>由分配给特定工作场景的所有硬件设备组成。它至少包含一个图形设备，通常还有键盘和鼠标。此外，它可能包括摄像头、声卡等设备。座位由座位名称标识，这是一个短字符串（不超过64个字符），以”seat”四个字符开头，后跟至少一个a-zA-Z0-9范围内的字符，或”_”和”-“。这种命名方式适合用于文件名。座位名称可能是稳定的，也可能不稳定，如果座位再次可用，其名称可以重复使用。</p>
<h3 id="RHI"><a href="#RHI" class="headerlink" title="RHI"></a>RHI</h3><p>RHI 是 <code>Renderer Hardware Interface</code>（渲染硬件接口）的缩写，是一套对硬件的抽象，在上层只需要设置参数，底层具体使用的是 OpenGL、Vulkan、DX12 还是 Metal 哪套接口，我们是不必关心的。</p>
<p>Qt6 提供了 QRHI，为 Qt 程序提供了底层的硬件抽象，这样上层的 QtQuick 组件在执行 GPU 渲染时，就可以自动调用对应的驱动接口。</p>
<h3 id="QPA"><a href="#QPA" class="headerlink" title="QPA"></a>QPA</h3><p>Qt 平台抽象（QPA）是 Qt 中的核心平台抽象层。</p>
<p>QPA 的 API 可通过类前缀”QPlatform*”识别，用于实现 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtgui-index.html">Qt GUI</a> 中的高级类。例如，<code>QPlatformWindow</code> 用于窗口系统集成，而 <code>QPlatformTheme</code> 和 <code>QStyleHint</code> 则用于深层次的平台主题和集成。</p>
<h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><p><code>Treeland</code> 使用 <code>QQuickWindow</code> 作为渲染的根，这样在 <code>Treeland</code> 里开发时，就如同开发一个普通 Qt 程序一样，先创建一个 Window，在 Window 内创建 Qt 控件，使用 QEvent 处理各种事件。</p>
<p>那么 Treeland 是如何实现这件事的呢？</p>
<p><code>QQuickWindow</code> 的私有类提供了自定义 <code>QQuickGraphicsDevice</code> 对象的接口，而 <code>QQuickGraphicsDevice</code> 可以使用 <code>fromOpenGLContext</code> 和 <code>fromPhyicalDevice</code> 创建新的对象，那么 <code>Treeland</code> 只需要继承 <code>QQuickWindow</code>，并从 <code>wlroots</code> 获取 OpenGL context 和 phyical device，就可以将 Qt QuickWindow 的渲染，嫁接到 <code>wlroots</code> 上。</p>
<p>通过将 <code>wlroots</code> 的渲染上下文与 Qt 的渲染上下文进行结合，可以将 <code>wlroots</code> 渲染的图形结果嵌入到 Qt 应用程序的渲染流程中，可以直接使用 <code>wlroots</code> 提供的图形资源和设备对象，如物理设备（<code>phdev</code>）、逻辑设备（<code>dev</code>）和队列族（<code>queue_family</code>），以减少不必要的上下文切换和资源拷贝。这样，Qt 就可以利用 <code>wlroots</code> 提供的渲染能力，同时能够继续使用 Qt 的渲染框架和 API。</p>
<p>之后在 Qt QPA 中将屏幕信息，以及输入信息转换成 Qt 内部对象，从而利用 Qt 自身的事件循环等机制继续处理。</p>
<h2 id="Qt-QPA"><a href="#Qt-QPA" class="headerlink" title="Qt QPA"></a>Qt QPA</h2><p>QPA 为 Qt 提供了跨平台的接口抽象能力，我们可以提供自己的 QPA 插件来为 Qt 程序提供新的能力，例如将 <code>wlroots</code> 的输入事件转换成 Qt 内部事件。</p>
<h3 id="输入事件处理"><a href="#输入事件处理" class="headerlink" title="输入事件处理"></a>输入事件处理</h3><img src= "" data-lazy-src="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/waylib.png" class="" title="Treeland 处理底层事件与上层事件的流程">

<p>Treeland 处理底层事件与上层事件的流程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WOutputRenderWindow::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(WOutputRenderWindow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == doRenderEventType) &#123;</span><br><span class="line">        QCoreApplication::<span class="built_in">removePostedEvents</span>(<span class="keyword">this</span>, doRenderEventType);</span><br><span class="line">        <span class="built_in">d_func</span>()-&gt;<span class="built_in">doRender</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QW::RenderWindow::<span class="built_in">beforeDisposeEventFilter</span>(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        QW::RenderWindow::<span class="built_in">afterDisposeEventFilter</span>(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isAccepted = QQuickWindow::<span class="built_in">event</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (QW::RenderWindow::<span class="built_in">afterDisposeEventFilter</span>(<span class="keyword">this</span>, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isAccepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>WOutputRenderWindow</code> 的事件处理中，会额外调用下 seat 的事件过滤器，确保合成器可以拦截掉一部分事件，例如将一部分按键拦截下来，不发送给客户端。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWlrootsRenderWindow::beforeDisposeEventFilter</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">isInputEvent</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ie = <span class="built_in">static_cast</span>&lt;QInputEvent*&gt;(event);</span><br><span class="line">        <span class="keyword">auto</span> device = WInputDevice::<span class="built_in">from</span>(ie-&gt;<span class="built_in">device</span>());</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(device);</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(device-&gt;<span class="built_in">seat</span>());</span><br><span class="line">        lastActiveCursor = device-&gt;<span class="built_in">seat</span>()-&gt;<span class="built_in">cursor</span>();</span><br><span class="line">        <span class="keyword">return</span> device-&gt;<span class="built_in">seat</span>()-&gt;<span class="built_in">filterEventBeforeDisposeStage</span>(<span class="built_in">window</span>(), ie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码展示了转换输入设备的功能，判断输入设备的类型，创建对应的 <code>QInputDevice</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QPointer&lt;QInputDevice&gt; <span class="title">QWlrootsIntegration::addInputDevice</span><span class="params">(WInputDevice *device, <span class="type">const</span> QString &amp;seatName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPointer&lt;QInputDevice&gt; qtdev;</span><br><span class="line">    <span class="keyword">auto</span> qwDevice = device-&gt;<span class="built_in">handle</span>();</span><br><span class="line">    <span class="type">const</span> QString name = QString::<span class="built_in">fromUtf8</span>(qwDevice-&gt;<span class="built_in">handle</span>()-&gt;name);</span><br><span class="line">    qint64 systemId = <span class="built_in">reinterpret_cast</span>&lt;qint64&gt;(device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (qwDevice-&gt;<span class="built_in">handle</span>()-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_KEYBOARD: &#123;</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QInputDevice</span>(name, systemId, QInputDevice::DeviceType::Keyboard, seatName);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_POINTER: &#123;</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QPointingDevice</span>(name, systemId, QInputDevice::DeviceType::TouchPad, QPointingDevice::PointerType::Generic,</span><br><span class="line">                                    QInputDevice::Capability::Position | QInputDevice::Capability::Hover</span><br><span class="line">                                        | QInputDevice::Capability::Scroll | QInputDevice::Capability::MouseEmulation,</span><br><span class="line">                                    <span class="number">10</span>, <span class="number">32</span>, seatName, <span class="built_in">QPointingDeviceUniqueId</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_TOUCH: &#123;</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QPointingDevice</span>(name, systemId, QInputDevice::DeviceType::TouchScreen, QPointingDevice::PointerType::Finger,</span><br><span class="line">                                    QInputDevice::Capability::Position | QInputDevice::Capability::Area | QInputDevice::Capability::MouseEmulation,</span><br><span class="line">                                    <span class="number">10</span>, <span class="number">32</span>, seatName, <span class="built_in">QPointingDeviceUniqueId</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_TABLET_TOOL: &#123;</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QPointingDevice</span>(name, systemId, QInputDevice::DeviceType::Stylus, QPointingDevice::PointerType::Pen,</span><br><span class="line">                                    QInputDevice::Capability::XTilt | QInputDevice::Capability::YTilt | QInputDevice::Capability::Pressure,</span><br><span class="line">                                    <span class="number">1</span>, <span class="number">32</span>, seatName, <span class="built_in">QPointingDeviceUniqueId</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_TABLET_PAD: &#123;</span><br><span class="line">        <span class="keyword">auto</span> pad = <span class="built_in">wlr_tablet_pad_from_input_device</span>(qwDevice-&gt;<span class="built_in">handle</span>());</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QPointingDevice</span>(name, systemId, QInputDevice::DeviceType::TouchPad, QPointingDevice::PointerType::Pen,</span><br><span class="line">                                    QInputDevice::Capability::Position | QInputDevice::Capability::Hover | QInputDevice::Capability::Pressure,</span><br><span class="line">                                    <span class="number">1</span>, pad-&gt;button_count, seatName, <span class="built_in">QPointingDeviceUniqueId</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WLR_INPUT_DEVICE_SWITCH: &#123;</span><br><span class="line">        qtdev = <span class="keyword">new</span> <span class="built_in">QInputDevice</span>(name, systemId, QInputDevice::DeviceType::Keyboard, seatName);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qtdev) &#123;</span><br><span class="line">        device-&gt;<span class="built_in">setQtDevice</span>(qtdev);</span><br><span class="line">        QWindowSystemInterface::<span class="built_in">registerInputDevice</span>(qtdev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qtdev-&gt;<span class="built_in">type</span>() == QInputDevice::DeviceType::Mouse || qtdev-&gt;<span class="built_in">type</span>() == QInputDevice::DeviceType::TouchPad) &#123;</span><br><span class="line">            <span class="keyword">auto</span> primaryQtDevice = QPointingDevice::<span class="built_in">primaryPointingDevice</span>();</span><br><span class="line">            <span class="keyword">if</span> (!WInputDevice::<span class="built_in">from</span>(primaryQtDevice)) &#123;</span><br><span class="line">                <span class="comment">// Ensure the primary pointing device is the WInputDevice</span></span><br><span class="line">                <span class="keyword">auto</span> pd = <span class="built_in">const_cast</span>&lt;QPointingDevice*&gt;(primaryQtDevice);</span><br><span class="line">                pd-&gt;<span class="built_in">setParent</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">delete</span> pd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(WInputDevice::<span class="built_in">from</span>(QPointingDevice::<span class="built_in">primaryPointingDevice</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qtdev-&gt;<span class="built_in">type</span>() == QInputDevice::DeviceType::Keyboard) &#123;</span><br><span class="line">            <span class="keyword">auto</span> primaryQtDevice = QInputDevice::<span class="built_in">primaryKeyboard</span>();</span><br><span class="line">            <span class="keyword">if</span> (!WInputDevice::<span class="built_in">from</span>(primaryQtDevice)) &#123;</span><br><span class="line">                <span class="comment">// Ensure the primary keyboard device is the WInputDevice</span></span><br><span class="line">                <span class="keyword">auto</span> pd = <span class="built_in">const_cast</span>&lt;QInputDevice*&gt;(primaryQtDevice);</span><br><span class="line">                pd-&gt;<span class="built_in">setParent</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">delete</span> pd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(WInputDevice::<span class="built_in">from</span>(QInputDevice::<span class="built_in">primaryKeyboard</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qtdev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端事件"><a href="#客户端事件" class="headerlink" title="客户端事件"></a>客户端事件</h3><p>在 Treeland 还有一种事件需要处理，当用户点击一个窗口，合成器需要告知客户端哪个坐标点击了。或者使用键盘进行输入时，需要告知客户端输入的内容。</p>
<p>首先，Treeland 会标记一个窗口成为激活窗口，设置给 seat，这样 <code>wlroots</code> 就知道哪个窗口此时拥有焦点。</p>
<p>之后当键盘发生输入事件时，Treeland 没有过滤掉按键事件，或者是放行某些按键，这些剩余的输入事件就会在 wseat 的 sendEvent 中，发送给激活的客户端。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for keyboard event</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">doNotifyKey</span><span class="params">(WInputDevice *device, <span class="type">uint32_t</span> keycode, <span class="type">uint32_t</span> state, <span class="type">uint32_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">keyboardFocusSurface</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">q_func</span>()-&gt;<span class="built_in">setKeyboard</span>(device);</span><br><span class="line">    <span class="comment">/* Send modifiers to the client. */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">handle</span>()-&gt;<span class="built_in">keyboard_notify_key</span>(timestamp, keycode, state);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="屏幕信息"><a href="#屏幕信息" class="headerlink" title="屏幕信息"></a>屏幕信息</h3><p>在 QPA 中还对 <code>WOutput</code> 进行了封装 <code>QWlrootsScreen</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QWlrootsScreen *<span class="title">QWlrootsIntegration::addScreen</span><span class="params">(WOutput *output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_screens &lt;&lt; <span class="keyword">new</span> <span class="built_in">QWlrootsScreen</span>(output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMaster</span>()) &#123;</span><br><span class="line">        QWindowSystemInterface::<span class="built_in">handleScreenAdded</span>(m_screens.<span class="built_in">last</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_placeholderScreen) &#123;</span><br><span class="line">            QWindowSystemInterface::<span class="built_in">handleScreenRemoved</span>(m_placeholderScreen.<span class="built_in">release</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(<span class="keyword">new</span> <span class="built_in">QScreen</span>(m_screens.<span class="built_in">last</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_screens.<span class="built_in">last</span>()-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    output-&gt;<span class="built_in">setScreen</span>(m_screens.<span class="built_in">last</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_screens.<span class="built_in">last</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QWlrootsScreen</code> 继承自 <code>QPlatformScreen</code>，做的事情是将部分参数进行转换，例如physicalSize、devicePixelRatio、DPI等，之后通过 <code>QWindowSystemInterface::handleScreenAdded</code> 将创建好的 <code>QWlrootsScreen</code> 添加进 Qt 内。</p>
<h2 id="Qt-RHI"><a href="#Qt-RHI" class="headerlink" title="Qt RHI"></a>Qt RHI</h2><p>摘抄一段来自 waylib 中初始化 Qt RHI 的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WOutputRenderWindowPrivate::initRCWithRhi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">W_Q</span>(WOutputRenderWindow);</span><br><span class="line"></span><br><span class="line">    QQuickRenderControlPrivate *rcd = QQuickRenderControlPrivate::<span class="built_in">get</span>(<span class="built_in">rc</span>());</span><br><span class="line">    QSGRhiSupport *rhiSupport = QSGRhiSupport::<span class="built_in">instance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check for Vulkan</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_VULKAN_RENDER</span></span><br><span class="line">    <span class="keyword">if</span> (rhiSupport-&gt;<span class="built_in">rhiBackend</span>() == QRhi::Vulkan) &#123;</span><br><span class="line">        vkInstance.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">QVulkanInstance</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> phdev = <span class="built_in">wlr_vk_renderer_get_physical_device</span>(m_renderer-&gt;<span class="built_in">handle</span>());</span><br><span class="line">        <span class="keyword">auto</span> dev = <span class="built_in">wlr_vk_renderer_get_device</span>(m_renderer-&gt;<span class="built_in">handle</span>());</span><br><span class="line">        <span class="keyword">auto</span> queue_family = <span class="built_in">wlr_vk_renderer_get_queue_family</span>(m_renderer-&gt;<span class="built_in">handle</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &gt; QT_VERSION_CHECK(6, 6, 0)</span></span><br><span class="line">        <span class="keyword">auto</span> instance = <span class="built_in">wlr_vk_renderer_get_instance</span>(m_renderer-&gt;<span class="built_in">handle</span>());</span><br><span class="line">        vkInstance-&gt;<span class="built_in">setVkInstance</span>(instance);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//        vkInstance-&gt;setExtensions(fromCStyleList(vkRendererAttribs.extension_count, vkRendererAttribs.extensions));</span></span><br><span class="line">        <span class="comment">//        vkInstance-&gt;setLayers(fromCStyleList(vkRendererAttribs.layer_count, vkRendererAttribs.layers));</span></span><br><span class="line">        vkInstance-&gt;<span class="built_in">setApiVersion</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        vkInstance-&gt;<span class="built_in">create</span>();</span><br><span class="line">        q-&gt;<span class="built_in">setVulkanInstance</span>(vkInstance.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> gd = QQuickGraphicsDevice::<span class="built_in">fromDeviceObjects</span>(phdev, dev, queue_family);</span><br><span class="line">        q-&gt;<span class="built_in">setGraphicsDevice</span>(gd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (rhiSupport-&gt;<span class="built_in">rhiBackend</span>() == QRhi::OpenGLES2) &#123;</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(<span class="built_in">wlr_renderer_is_gles2</span>(m_renderer-&gt;<span class="built_in">handle</span>()));</span><br><span class="line">        <span class="keyword">auto</span> egl = <span class="built_in">wlr_gles2_renderer_get_egl</span>(m_renderer-&gt;<span class="built_in">handle</span>());</span><br><span class="line">        <span class="keyword">auto</span> display = <span class="built_in">wlr_egl_get_display</span>(egl);</span><br><span class="line">        <span class="keyword">auto</span> context = <span class="built_in">wlr_egl_get_context</span>(egl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;glContext = <span class="keyword">new</span> QW::<span class="built_in">OpenGLContext</span>(display, context, <span class="built_in">rc</span>());</span><br><span class="line">        <span class="type">bool</span> ok = <span class="keyword">this</span>-&gt;glContext-&gt;<span class="built_in">create</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        q-&gt;<span class="built_in">setGraphicsDevice</span>(QQuickGraphicsDevice::<span class="built_in">fromOpenGLContext</span>(<span class="keyword">this</span>-&gt;glContext));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QOffscreenSurface *offscreenSurface = <span class="keyword">new</span> QW::<span class="built_in">OffscreenSurface</span>(<span class="literal">nullptr</span>, q);</span><br><span class="line">    offscreenSurface-&gt;<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line">    QSGRhiSupport::RhiCreateResult result = rhiSupport-&gt;<span class="built_in">createRhi</span>(q, offscreenSurface);</span><br><span class="line">    <span class="keyword">if</span> (!result.rhi) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;WOutput::initRhi: Failed to initialize QRhi&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcd-&gt;rhi = result.rhi;</span><br><span class="line">    <span class="comment">// Ensure the QQuickRenderControl don&#x27;t reinit the RHI</span></span><br><span class="line">    rcd-&gt;ownRhi = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">rc</span>()-&gt;<span class="built_in">initialize</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rcd-&gt;ownRhi = result.own;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(rcd-&gt;rhi == result.rhi);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(!swapchain);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取 <code>QSGRhiSupport</code> 及相关控制对象。</p>
<p>判断 RHI backend 的类型，需要适配 <code>vulkan</code>、<code>gles</code>等。</p>
<p>从 <code>wlroots</code> 获取物理设备等参数，使用 <code>QQuickGraphicsDevice::fromDeviceObjects</code> 创建 Qt 的 <code>QQuickGraphicsDevice</code>。</p>
<p>render window的私有类是继承自 <code>QQuickWindowPrivate</code>，只需要将获取到的 <code>QQuickGraphicsDevice</code> 设置给 <code>QQuickWindowPrivate::setGraphicsDevice</code> 即可。</p>
<p>之后创建一个离屏渲染表面，用于 RHI 的初始化。</p>
<h2 id="Qt-Viewport"><a href="#Qt-Viewport" class="headerlink" title="Qt Viewport"></a>Qt Viewport</h2><p>在 Qt 中，想要查看或者渲染一个组件，需要使用 Viewport 组件，俗称照相机。</p>
<p>视口（Viewport）是一个可观察的多边形区域，只有 Viewport 范围内的画面才能显示到屏幕上。</p>
<p><code>wlroots</code> 中的 <strong>Viewport</strong> 是一个与 <code>Wayland</code> 显示协议相关的概念，主要用于定义渲染输出在屏幕上的显示区域。它允许在渲染时对显示内容进行缩放、裁剪或平移，以适应不同的分辨率和显示需求。</p>
<p>Treeland 使用 <code>WOutputViewport</code> 提供 Viewport 功能，使用 <code>wlroots</code> 的 <code>wlr_output</code> 中的屏幕信息，对画面进行矩阵变换，这里会涉及到屏幕的缩放、DPI等参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QMatrix4x4 <span class="title">WOutputViewport::renderMatrix</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMatrix4x4 renderMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> customTransform = <span class="built_in">viewportTransform</span>()) &#123;</span><br><span class="line">        customTransform-&gt;<span class="built_in">applyTo</span>(&amp;renderMatrix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">parentItem</span>() &amp;&amp; !<span class="built_in">ignoreViewport</span>() &amp;&amp; <span class="built_in">input</span>() != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> d = QQuickItemPrivate::<span class="built_in">get</span>(<span class="built_in">const_cast</span>&lt;WOutputViewport*&gt;(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">auto</span> viewportMatrix = d-&gt;<span class="built_in">itemNode</span>()-&gt;<span class="built_in">matrix</span>().<span class="built_in">inverted</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> inputItem = <span class="built_in">input</span>()) &#123;</span><br><span class="line">            QMatrix4x4 matrix = QQuickItemPrivate::<span class="built_in">get</span>(<span class="built_in">parentItem</span>())-&gt;<span class="built_in">itemToWindowTransform</span>();</span><br><span class="line">            matrix *= QQuickItemPrivate::<span class="built_in">get</span>(inputItem)-&gt;<span class="built_in">windowToItemTransform</span>();</span><br><span class="line">            renderMatrix = viewportMatrix * matrix.<span class="built_in">inverted</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the input item is window&#x27;s contentItem</span></span><br><span class="line">            <span class="keyword">auto</span> pd = QQuickItemPrivate::<span class="built_in">get</span>(<span class="built_in">parentItem</span>());</span><br><span class="line">            QMatrix4x4 parentMatrix = pd-&gt;<span class="built_in">itemToWindowTransform</span>().<span class="built_in">inverted</span>();</span><br><span class="line">            renderMatrix = viewportMatrix * parentMatrix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renderMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WOutputViewport</code> 提供了 Viewport 所需的所有参数，变换矩阵、源几何大小、目标几何大小等信息。</p>
<p>在 <code>WOutputRenderWindow</code> 的事件中，判断如果是渲染的事件，就执行渲染。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WOutputRenderWindow::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(WOutputRenderWindow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == doRenderEventType) &#123;</span><br><span class="line">        QCoreApplication::<span class="built_in">removePostedEvents</span>(<span class="keyword">this</span>, doRenderEventType);</span><br><span class="line">        <span class="built_in">d_func</span>()-&gt;<span class="built_in">doRender</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QW::RenderWindow::<span class="built_in">beforeDisposeEventFilter</span>(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        QW::RenderWindow::<span class="built_in">afterDisposeEventFilter</span>(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isAccepted = QQuickWindow::<span class="built_in">event</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (QW::RenderWindow::<span class="built_in">afterDisposeEventFilter</span>(<span class="keyword">this</span>, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isAccepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doRender 中，遍历所有的 Output，执行 beginRender，然后执行 Output 的渲染。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WOutputRenderWindowPrivate::doRender</span><span class="params">(<span class="type">const</span> QList&lt;OutputHelper *&gt; &amp;outputs,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">bool</span> forceRender, <span class="type">bool</span> doCommit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(rendererList.<span class="built_in">isEmpty</span>());</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(!inRendering);</span><br><span class="line">    inRendering = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">W_Q</span>(WOutputRenderWindow);</span><br><span class="line">    <span class="keyword">for</span> (OutputLayer *layer : std::<span class="built_in">as_const</span>(layers)) &#123;</span><br><span class="line">        layer-&gt;<span class="built_in">beforeRender</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rc</span>()-&gt;<span class="built_in">polishItems</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QSGRendererInterface::<span class="built_in">isApiRhiBased</span>(WRenderHelper::<span class="built_in">getGraphicsApi</span>()))</span><br><span class="line">        <span class="built_in">rc</span>()-&gt;<span class="built_in">beginFrame</span>();</span><br><span class="line">    <span class="built_in">rc</span>()-&gt;<span class="built_in">sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QQuickAnimatorController_advance</span>(animationController.<span class="built_in">get</span>());</span><br><span class="line">    Q_EMIT q-&gt;<span class="built_in">beforeRendering</span>();</span><br><span class="line">    <span class="built_in">runAndClearJobs</span>(&amp;beforeRenderingJobs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> needsCommit = <span class="built_in">doRenderOutputs</span>(outputs, forceRender);</span><br><span class="line"></span><br><span class="line">    Q_EMIT q-&gt;<span class="built_in">afterRendering</span>();</span><br><span class="line">    <span class="built_in">runAndClearJobs</span>(&amp;afterRenderingJobs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QSGRendererInterface::<span class="built_in">isApiRhiBased</span>(WRenderHelper::<span class="built_in">getGraphicsApi</span>()))</span><br><span class="line">        <span class="built_in">rc</span>()-&gt;<span class="built_in">endFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doCommit) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : std::<span class="built_in">as_const</span>(needsCommit)) &#123;</span><br><span class="line">            <span class="type">bool</span> ok = i.first-&gt;<span class="built_in">commit</span>(i.second);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i.second-&gt;<span class="built_in">currentBuffer</span>()) &#123;</span><br><span class="line">                i.second-&gt;<span class="built_in">endRender</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i.first-&gt;<span class="built_in">resetState</span>(ok);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resetGlState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On Intel&amp;Nvidia multi-GPU environment, wlroots using Intel card do render for all</span></span><br><span class="line">    <span class="comment">// outputs, and blit nvidia&#x27;s output buffer in drm_connector_state_update_primary_fb,</span></span><br><span class="line">    <span class="comment">// the &#x27;blit&#x27; behavior will make EGL context to Nvidia renderer. So must done current</span></span><br><span class="line">    <span class="comment">// OpenGL context here in order to ensure QtQuick always make EGL context to Intel</span></span><br><span class="line">    <span class="comment">// renderer before next frame.</span></span><br><span class="line">    <span class="keyword">if</span> (glContext)</span><br><span class="line">        glContext-&gt;<span class="built_in">doneCurrent</span>();</span><br><span class="line"></span><br><span class="line">    inRendering = <span class="literal">false</span>;</span><br><span class="line">    Q_EMIT q-&gt;<span class="built_in">renderEnd</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">qw_buffer *<span class="title">WBufferRenderer::beginRender</span><span class="params">(<span class="type">const</span> QSize &amp;pixelSize, qreal devicePixelRatio,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> format, RenderFlags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(!state.buffer);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(m_output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pixelSize.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Q_EMIT <span class="title">beforeRendering</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    m_damageRing.<span class="built_in">set_bounds</span>(pixelSize.<span class="built_in">width</span>(), pixelSize.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure swapchain</span></span><br><span class="line">    <span class="keyword">if</span> (flags.<span class="built_in">testFlag</span>(RenderFlag::DontConfigureSwapchain)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> renderFormat = <span class="built_in">pickFormat</span>(m_output-&gt;<span class="built_in">renderer</span>(), format);</span><br><span class="line">        <span class="keyword">if</span> (!renderFormat) &#123;</span><br><span class="line">            <span class="built_in">qWarning</span>(<span class="string">&quot;wlr_renderer doesn&#x27;t support format 0x%s&quot;</span>, <span class="built_in">drmGetFormatName</span>(format));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_swapchain || <span class="built_in">QSize</span>(m_swapchain-&gt;<span class="built_in">handle</span>()-&gt;width, m_swapchain-&gt;<span class="built_in">handle</span>()-&gt;height) != pixelSize</span><br><span class="line">            || m_swapchain-&gt;<span class="built_in">handle</span>()-&gt;format.format != renderFormat-&gt;format) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_swapchain)</span><br><span class="line">                <span class="keyword">delete</span> m_swapchain;</span><br><span class="line">            m_swapchain = qw_swapchain::<span class="built_in">create</span>(m_output-&gt;<span class="built_in">allocator</span>()-&gt;<span class="built_in">handle</span>(), pixelSize.<span class="built_in">width</span>(), pixelSize.<span class="built_in">height</span>(), renderFormat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags.<span class="built_in">testFlag</span>(RenderFlag::UseCursorFormats)) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = m_output-&gt;<span class="built_in">configureCursorSwapchain</span>(pixelSize, format, &amp;m_swapchain);</span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">bool</span> ok = m_output-&gt;<span class="built_in">configurePrimarySwapchain</span>(pixelSize, format, &amp;m_swapchain,</span><br><span class="line">                                                      !flags.<span class="built_in">testFlag</span>(DontTestSwapchain));</span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Support scanout buffer of wlr_surface(from WSurfaceItem)</span></span><br><span class="line">    <span class="type">int</span> bufferAge;</span><br><span class="line">    <span class="keyword">auto</span> wbuffer = m_swapchain-&gt;<span class="built_in">acquire</span>(&amp;bufferAge);</span><br><span class="line">    <span class="keyword">if</span> (!wbuffer)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> buffer = qw_buffer::<span class="built_in">from</span>(wbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_renderHelper)</span><br><span class="line">        m_renderHelper = <span class="keyword">new</span> <span class="built_in">WRenderHelper</span>(m_output-&gt;<span class="built_in">renderer</span>());</span><br><span class="line">    m_renderHelper-&gt;<span class="built_in">setSize</span>(pixelSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> wd = QQuickWindowPrivate::<span class="built_in">get</span>(<span class="built_in">window</span>());</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(wd-&gt;renderControl);</span><br><span class="line">    <span class="keyword">auto</span> lastRT = m_renderHelper-&gt;<span class="built_in">lastRenderTarget</span>();</span><br><span class="line">    <span class="keyword">auto</span> rt = m_renderHelper-&gt;<span class="built_in">acquireRenderTarget</span>(wd-&gt;renderControl, buffer);</span><br><span class="line">    <span class="keyword">if</span> (rt.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        buffer-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rtd = QQuickRenderTargetPrivate::<span class="built_in">get</span>(&amp;rt);</span><br><span class="line">    QSGRenderTarget sgRT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;type == QQuickRenderTargetPrivate::Type::PaintDevice) &#123;</span><br><span class="line">        sgRT.paintDevice = rtd-&gt;u.paintDevice;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(rtd-&gt;type == QQuickRenderTargetPrivate::Type::RhiRenderTarget);</span><br><span class="line">        sgRT.rt = rtd-&gt;u.rhiRt;</span><br><span class="line">        sgRT.cb = wd-&gt;redirect.commandBuffer;</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(sgRT.cb);</span><br><span class="line">        sgRT.rpDesc = rtd-&gt;u.rhiRt-&gt;<span class="built_in">renderPassDescriptor</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_OPENGL</span></span><br><span class="line">        <span class="keyword">if</span> (wd-&gt;rhi-&gt;<span class="built_in">backend</span>() == QRhi::OpenGLES2) &#123;</span><br><span class="line">            <span class="keyword">auto</span> glRT = <span class="built_in">QRHI_RES</span>(QGles2TextureRenderTarget, rtd-&gt;u.rhiRt);</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(glRT-&gt;framebuffer &gt;= <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">auto</span> glContext = QOpenGLContext::<span class="built_in">currentContext</span>();</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(glContext);</span><br><span class="line">            QOpenGLContextPrivate::<span class="built_in">get</span>(glContext)-&gt;defaultFboRedirect = glRT-&gt;framebuffer;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state.flags = flags;</span><br><span class="line">    state.context = wd-&gt;context;</span><br><span class="line">    state.pixelSize = pixelSize;</span><br><span class="line">    state.devicePixelRatio = devicePixelRatio;</span><br><span class="line">    state.bufferAge = bufferAge;</span><br><span class="line">    state.lastRT = lastRT;</span><br><span class="line">    state.buffer = buffer;</span><br><span class="line">    state.renderTarget = rt;</span><br><span class="line">    state.sgRenderTarget = sgRT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QVector&lt;std::pair&lt;OutputHelper*, WBufferRenderer*&gt;&gt;</span><br><span class="line">WOutputRenderWindowPrivate::<span class="built_in">doRenderOutputs</span>(<span class="type">const</span> QList&lt;OutputHelper*&gt; &amp;outputs, <span class="type">bool</span> forceRender)</span><br><span class="line">&#123;</span><br><span class="line">    QVector&lt;OutputHelper*&gt; renderResults;</span><br><span class="line">    renderResults.<span class="built_in">reserve</span>(outputs.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (OutputHelper *helper : std::<span class="built_in">as_const</span>(outputs)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Q_LIKELY</span>(!forceRender)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!helper-&gt;<span class="built_in">renderable</span>()</span><br><span class="line">                || <span class="built_in">Q_UNLIKELY</span>(!WOutputViewportPrivate::<span class="built_in">get</span>(helper-&gt;<span class="built_in">output</span>())-&gt;<span class="built_in">renderable</span>())</span><br><span class="line">                || !helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">isEnabled</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!helper-&gt;<span class="built_in">contentIsDirty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper-&gt;<span class="built_in">needsFrame</span>())</span><br><span class="line">                    renderResults.<span class="built_in">append</span>(helper);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">scale</span>() &lt;= helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">devicePixelRatio</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;format = helper-&gt;<span class="built_in">qwoutput</span>()-&gt;<span class="built_in">handle</span>()-&gt;render_format;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> renderMatrix = helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">renderMatrix</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maybe using the other WOutputViewport&#x27;s QSGTextureProvider</span></span><br><span class="line">        <span class="keyword">if</span> (!helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">depends</span>().<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="built_in">updateDirtyNodes</span>();</span><br><span class="line"></span><br><span class="line">        qw_buffer *buffer = helper-&gt;<span class="built_in">beginRender</span>(helper-&gt;<span class="built_in">bufferRenderer</span>(), helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">size</span>(), format,</span><br><span class="line">                                                WBufferRenderer::RedirectOpenGLContextDefaultFrameBufferObject);</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(buffer == helper-&gt;<span class="built_in">bufferRenderer</span>()-&gt;<span class="built_in">currentBuffer</span>());</span><br><span class="line">        <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">            helper-&gt;<span class="built_in">render</span>(helper-&gt;<span class="built_in">bufferRenderer</span>(), <span class="number">0</span>, renderMatrix,</span><br><span class="line">                           helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">effectiveSourceRect</span>(),</span><br><span class="line">                           helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">targetRect</span>(),</span><br><span class="line">                           helper-&gt;<span class="built_in">output</span>()-&gt;<span class="built_in">preserveColorContents</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        renderResults.<span class="built_in">append</span>(helper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QVector&lt;std::pair&lt;OutputHelper*, WBufferRenderer*&gt;&gt; needsCommit;</span><br><span class="line">    needsCommit.<span class="built_in">reserve</span>(renderResults.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> helper : std::<span class="built_in">as_const</span>(renderResults)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> bufferRenderer = helper-&gt;<span class="built_in">afterRender</span>();</span><br><span class="line">        <span class="keyword">if</span> (bufferRenderer)</span><br><span class="line">            needsCommit.<span class="built_in">append</span>(&#123;helper, bufferRenderer&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rendererList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> needsCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WBufferRenderer::render</span><span class="params">(<span class="type">int</span> sourceIndex, <span class="type">const</span> QMatrix4x4 &amp;renderMatrix,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> QRectF &amp;sourceRect, <span class="type">const</span> QRectF &amp;targetRect,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> preserveColorContents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(state.buffer);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;source = m_sourceList.<span class="built_in">at</span>(sourceIndex);</span><br><span class="line">    QSGRenderer *renderer = <span class="built_in">ensureRenderer</span>(sourceIndex, state.context);</span><br><span class="line">    <span class="keyword">auto</span> wd = QQuickWindowPrivate::<span class="built_in">get</span>(<span class="built_in">window</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> qreal devicePixelRatio = state.devicePixelRatio;</span><br><span class="line">    state.renderer = renderer;</span><br><span class="line">    state.worldTransform = renderMatrix;</span><br><span class="line">    renderer-&gt;<span class="built_in">setDevicePixelRatio</span>(devicePixelRatio);</span><br><span class="line">    renderer-&gt;<span class="built_in">setDeviceRect</span>(<span class="built_in">QRect</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), state.pixelSize));</span><br><span class="line">    renderer-&gt;<span class="built_in">setRenderTarget</span>(state.sgRenderTarget);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> viewportRect = <span class="built_in">scaleToRect</span>(targetRect, devicePixelRatio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> softwareRenderer = <span class="built_in">dynamic_cast</span>&lt;QSGSoftwareRenderer*&gt;(renderer);</span><br><span class="line">    &#123; <span class="comment">// before render</span></span><br><span class="line">        <span class="keyword">if</span> (softwareRenderer) &#123;</span><br><span class="line">            <span class="comment">// because software renderer don&#x27;t supports viewportRect,</span></span><br><span class="line">            <span class="comment">// so use transform to simulation.</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> mapTransform = <span class="built_in">inputMapToOutput</span>(sourceRect, targetRect,</span><br><span class="line">                                                       state.pixelSize, state.devicePixelRatio);</span><br><span class="line">            <span class="keyword">if</span> (!mapTransform.<span class="built_in">isIdentity</span>())</span><br><span class="line">                state.worldTransform = mapTransform * state.worldTransform;</span><br><span class="line">            state.worldTransform.<span class="built_in">optimize</span>();</span><br><span class="line">            <span class="keyword">auto</span> image = <span class="built_in">getImageFrom</span>(state.renderTarget);</span><br><span class="line">            image-&gt;<span class="built_in">setDevicePixelRatio</span>(devicePixelRatio);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Should set to QSGSoftwareRenderer, but it&#x27;s not support specify matrix.</span></span><br><span class="line">            <span class="comment">// If transform is changed, it will full repaint.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isRootItem</span>(source.source)) &#123;</span><br><span class="line">                <span class="keyword">auto</span> rootTransform = QQuickItemPrivate::<span class="built_in">get</span>(wd-&gt;contentItem)-&gt;<span class="built_in">itemNode</span>();</span><br><span class="line">                <span class="keyword">if</span> (rootTransform-&gt;<span class="built_in">matrix</span>() != state.worldTransform)</span><br><span class="line">                    rootTransform-&gt;<span class="built_in">setMatrix</span>(state.worldTransform);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = state.worldTransform.<span class="built_in">toTransform</span>();</span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">type</span>() &gt; QTransform::TxTranslate) &#123;</span><br><span class="line">                    (image-&gt;<span class="keyword">operator</span> QImage &amp;()).<span class="built_in">fill</span>(renderer-&gt;<span class="built_in">clearColor</span>());</span><br><span class="line">                    softwareRenderer-&gt;<span class="built_in">markDirty</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">applyTransform</span>(softwareRenderer, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state.worldTransform.<span class="built_in">optimize</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> flipY = wd-&gt;rhi ? !wd-&gt;rhi-&gt;<span class="built_in">isYUpInNDC</span>() : <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (state.renderTarget.<span class="built_in">mirrorVertically</span>())</span><br><span class="line">                flipY = !flipY;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (viewportRect.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">                QRect vr = viewportRect;</span><br><span class="line">                <span class="keyword">if</span> (flipY)</span><br><span class="line">                    vr.<span class="built_in">moveTop</span>(-vr.<span class="built_in">y</span>() + state.pixelSize.<span class="built_in">height</span>() - vr.<span class="built_in">height</span>());</span><br><span class="line">                renderer-&gt;<span class="built_in">setViewportRect</span>(vr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                renderer-&gt;<span class="built_in">setViewportRect</span>(<span class="built_in">QRect</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), state.pixelSize));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QRectF rect = sourceRect;</span><br><span class="line">            <span class="keyword">if</span> (!rect.<span class="built_in">isValid</span>())</span><br><span class="line">                rect = <span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">QSizeF</span>(state.pixelSize) / devicePixelRatio);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> left = rect.<span class="built_in">x</span>();</span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> right = rect.<span class="built_in">x</span>() + rect.<span class="built_in">width</span>();</span><br><span class="line">            <span class="type">float</span> bottom = rect.<span class="built_in">y</span>() + rect.<span class="built_in">height</span>();</span><br><span class="line">            <span class="type">float</span> top = rect.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flipY)</span><br><span class="line">                std::<span class="built_in">swap</span>(top, bottom);</span><br><span class="line"></span><br><span class="line">            QMatrix4x4 matrix;</span><br><span class="line">            matrix.<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            QMatrix4x4 projectionMatrix, projectionMatrixWithNativeNDC;</span><br><span class="line">            projectionMatrix = matrix * state.worldTransform;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (wd-&gt;rhi &amp;&amp; !wd-&gt;rhi-&gt;<span class="built_in">isYUpInNDC</span>()) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(top, bottom);</span><br><span class="line"></span><br><span class="line">                matrix.<span class="built_in">setToIdentity</span>();</span><br><span class="line">                matrix.<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            projectionMatrixWithNativeNDC = matrix * state.worldTransform;</span><br><span class="line"></span><br><span class="line">            renderer-&gt;<span class="built_in">setProjectionMatrix</span>(projectionMatrix);</span><br><span class="line">            renderer-&gt;<span class="built_in">setProjectionMatrixWithNativeNDC</span>(projectionMatrixWithNativeNDC);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> textureRT = <span class="built_in">static_cast</span>&lt;QRhiTextureRenderTarget*&gt;(state.sgRenderTarget.rt);</span><br><span class="line">            <span class="keyword">if</span> (preserveColorContents) &#123;</span><br><span class="line">                textureRT-&gt;<span class="built_in">setFlags</span>(textureRT-&gt;<span class="built_in">flags</span>() | QRhiTextureRenderTarget::PreserveColorContents);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                textureRT-&gt;<span class="built_in">setFlags</span>(textureRT-&gt;<span class="built_in">flags</span>() &amp; ~QRhiTextureRenderTarget::PreserveColorContents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state.context-&gt;<span class="built_in">renderNextFrame</span>(renderer);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// after render</span></span><br><span class="line">        <span class="keyword">if</span> (!softwareRenderer) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> get damage area from QRhi renderer</span></span><br><span class="line">            m_damageRing.<span class="built_in">add_whole</span>();</span><br><span class="line">            <span class="comment">// ###: maybe Qt bug? Before executing QRhi::endOffscreenFrame, we may</span></span><br><span class="line">            <span class="comment">// use the same QSGRenderer for multiple drawings. This can lead to</span></span><br><span class="line">            <span class="comment">// rendering the same content for different QSGRhiRenderTarget instances</span></span><br><span class="line">            <span class="comment">// when using the RhiGles backend. Additionally, considering that the</span></span><br><span class="line">            <span class="comment">// result of the current drawing may be needed when drawing the next</span></span><br><span class="line">            <span class="comment">// sourceIndex, we should let the RHI (Rendering Hardware Interface)</span></span><br><span class="line">            <span class="comment">// complete the results of this drawing here to ensure the current</span></span><br><span class="line">            <span class="comment">// drawing result is available for use.</span></span><br><span class="line">            wd-&gt;rhi-&gt;<span class="built_in">finish</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> currentImage = <span class="built_in">getImageFrom</span>(state.renderTarget);</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(currentImage &amp;&amp; currentImage == softwareRenderer-&gt;m_rt.paintDevice);</span><br><span class="line">            currentImage-&gt;<span class="built_in">setDevicePixelRatio</span>(<span class="number">1.0</span>);</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> scaleTF = QTransform::<span class="built_in">fromScale</span>(devicePixelRatio, devicePixelRatio);</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> scaledFlushRegion = scaleTF.<span class="built_in">map</span>(softwareRenderer-&gt;<span class="built_in">flushRegion</span>());</span><br><span class="line">            PixmanRegion scaledFlushDamage;</span><br><span class="line">            <span class="type">bool</span> ok = WTools::<span class="built_in">toPixmanRegion</span>(scaledFlushRegion, scaledFlushDamage);</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(ok);</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                PixmanRegion damage;</span><br><span class="line">                m_damageRing.<span class="built_in">get_buffer_damage</span>(state.bufferAge, damage);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (viewportRect.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">                    QRect imageRect = (currentImage-&gt;<span class="keyword">operator</span> <span class="type">const</span> QImage &amp;()).<span class="built_in">rect</span>();</span><br><span class="line">                    <span class="function">QRegion <span class="title">invalidRegion</span><span class="params">(imageRect)</span></span>;</span><br><span class="line">                    invalidRegion -= viewportRect;</span><br><span class="line">                    <span class="keyword">if</span> (!scaledFlushRegion.<span class="built_in">isEmpty</span>())</span><br><span class="line">                        invalidRegion &amp;= scaledFlushRegion;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!invalidRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                        <span class="function">QPainter <span class="title">pa</span><span class="params">(currentImage)</span></span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> r : std::<span class="built_in">as_const</span>(invalidRegion))</span><br><span class="line">                            pa.<span class="built_in">fillRect</span>(r, softwareRenderer-&gt;<span class="built_in">clearColor</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!damage.<span class="built_in">isEmpty</span>() &amp;&amp; state.lastRT.first != state.buffer &amp;&amp; !state.lastRT.second.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> image = <span class="built_in">getImageFrom</span>(state.lastRT.second);</span><br><span class="line">                    <span class="built_in">Q_ASSERT</span>(image);</span><br><span class="line">                    <span class="built_in">Q_ASSERT</span>(image-&gt;<span class="built_in">size</span>() == state.pixelSize);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Don&#x27;t use the previous render target, we can get the damage region of QtQuick</span></span><br><span class="line">                    <span class="comment">// before QQuickRenderControl::render for qw_damage_ring, and add dirty region to</span></span><br><span class="line">                    <span class="comment">// QSGAbstractSoftwareRenderer to force repaint the damage region of current render target.</span></span><br><span class="line">                    <span class="function">QPainter <span class="title">pa</span><span class="params">(currentImage)</span></span>;</span><br><span class="line"></span><br><span class="line">                    PixmanRegion remainderDamage;</span><br><span class="line">                    ok = <span class="built_in">pixman_region32_subtract</span>(remainderDamage, damage, scaledFlushDamage);</span><br><span class="line">                    <span class="built_in">Q_ASSERT</span>(ok);</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">auto</span> rects = <span class="built_in">pixman_region32_rectangles</span>(remainderDamage, &amp;count);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> r = rects[i];</span><br><span class="line">                        pa.<span class="built_in">drawImage</span>(r.x1, r.y1, *image, r.x1, r.y1, r.x2 - r.x1, r.y2 - r.y1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isRootItem</span>(source.source))</span><br><span class="line">                <span class="built_in">applyTransform</span>(softwareRenderer, state.worldTransform.<span class="built_in">inverted</span>().<span class="built_in">toTransform</span>());</span><br><span class="line">            m_damageRing.<span class="built_in">add</span>(scaledFlushDamage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> dr = <span class="built_in">qobject_cast</span>&lt;QSGDefaultRenderContext*&gt;(state.context)) &#123;</span><br><span class="line">        QRhiResourceUpdateBatch *resourceUpdates = wd-&gt;rhi-&gt;<span class="built_in">nextResourceUpdateBatch</span>();</span><br><span class="line">        dr-&gt;<span class="built_in">currentFrameCommandBuffer</span>()-&gt;<span class="built_in">resourceUpdate</span>(resourceUpdates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shouldCacheBuffer</span>())</span><br><span class="line">        <span class="built_in">wTextureProvider</span>()-&gt;<span class="built_in">setBuffer</span>(state.buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理完画面以后，如果需要上屏画面，就调用 commit 把画面送到屏幕上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OutputHelper::commit</span><span class="params">(WBufferRenderer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">output</span>()-&gt;<span class="built_in">offscreen</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!buffer || !buffer-&gt;<span class="built_in">currentBuffer</span>()) &#123;</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(!<span class="keyword">this</span>-&gt;<span class="built_in">buffer</span>());</span><br><span class="line">        <span class="keyword">return</span> WOutputHelper::<span class="built_in">commit</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setBuffer</span>(buffer-&gt;<span class="built_in">currentBuffer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_lastCommitBuffer == buffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pixman_region32_not_empty</span>(&amp;buffer-&gt;<span class="built_in">damageRing</span>()-&gt;<span class="built_in">handle</span>()-&gt;current))</span><br><span class="line">            <span class="built_in">setDamage</span>(&amp;buffer-&gt;<span class="built_in">damageRing</span>()-&gt;<span class="built_in">handle</span>()-&gt;current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_lastCommitBuffer = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WOutputHelper::<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还会判断是否有硬件加速（GPU），会优先使用硬件来加速计算过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    state.worldTransform.<span class="built_in">optimize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flipY = wd-&gt;rhi ? !wd-&gt;rhi-&gt;<span class="built_in">isYUpInNDC</span>() : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state.renderTarget.<span class="built_in">mirrorVertically</span>())</span><br><span class="line">        flipY = !flipY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewportRect.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        QRect vr = viewportRect;</span><br><span class="line">        <span class="keyword">if</span> (flipY)</span><br><span class="line">            vr.<span class="built_in">moveTop</span>(-vr.<span class="built_in">y</span>() + state.pixelSize.<span class="built_in">height</span>() - vr.<span class="built_in">height</span>());</span><br><span class="line">        renderer-&gt;<span class="built_in">setViewportRect</span>(vr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        renderer-&gt;<span class="built_in">setViewportRect</span>(<span class="built_in">QRect</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), state.pixelSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QRectF rect = sourceRect;</span><br><span class="line">    <span class="keyword">if</span> (!rect.<span class="built_in">isValid</span>())</span><br><span class="line">        rect = <span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">QSizeF</span>(state.pixelSize) / devicePixelRatio);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> left = rect.<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> right = rect.<span class="built_in">x</span>() + rect.<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">float</span> bottom = rect.<span class="built_in">y</span>() + rect.<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">float</span> top = rect.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flipY)</span><br><span class="line">        std::<span class="built_in">swap</span>(top, bottom);</span><br><span class="line"></span><br><span class="line">    QMatrix4x4 matrix;</span><br><span class="line">    matrix.<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    QMatrix4x4 projectionMatrix, projectionMatrixWithNativeNDC;</span><br><span class="line">    projectionMatrix = matrix * state.worldTransform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wd-&gt;rhi &amp;&amp; !wd-&gt;rhi-&gt;<span class="built_in">isYUpInNDC</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(top, bottom);</span><br><span class="line"></span><br><span class="line">        matrix.<span class="built_in">setToIdentity</span>();</span><br><span class="line">        matrix.<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    projectionMatrixWithNativeNDC = matrix * state.worldTransform;</span><br><span class="line"></span><br><span class="line">    renderer-&gt;<span class="built_in">setProjectionMatrix</span>(projectionMatrix);</span><br><span class="line">    renderer-&gt;<span class="built_in">setProjectionMatrixWithNativeNDC</span>(projectionMatrixWithNativeNDC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> textureRT = <span class="built_in">static_cast</span>&lt;QRhiTextureRenderTarget*&gt;(state.sgRenderTarget.rt);</span><br><span class="line">    <span class="keyword">if</span> (preserveColorContents) &#123;</span><br><span class="line">        textureRT-&gt;<span class="built_in">setFlags</span>(textureRT-&gt;<span class="built_in">flags</span>() | QRhiTextureRenderTarget::PreserveColorContents);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        textureRT-&gt;<span class="built_in">setFlags</span>(textureRT-&gt;<span class="built_in">flags</span>() &amp; ~QRhiTextureRenderTarget::PreserveColorContents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface-渲染"><a href="#Surface-渲染" class="headerlink" title="Surface 渲染"></a>Surface 渲染</h2><p>在 Treeland 中，为 Surface 创建了 <code>WSurfaceItem</code>，用于表示一个窗口，并创建了 <code>WSurfaceContent</code> 作为 <code>WSurfaceItem</code> 的 delegate。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WSurfaceItemPrivate::initForDelegate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_Q</span>(WSurfaceItem);</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;QQuickItem&gt; newContentContainer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!delegate) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getItemContent</span>()) &#123;</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(!delegateIsDirty);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delegateIsDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> contentItem = <span class="keyword">new</span> <span class="built_in">WSurfaceItemContent</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (surface)</span><br><span class="line">            contentItem-&gt;<span class="built_in">setSurface</span>(surface);</span><br><span class="line">        contentItem-&gt;<span class="built_in">setCacheLastBuffer</span>(!surfaceFlags.<span class="built_in">testFlag</span>(WSurfaceItem::DontCacheLastBuffer));</span><br><span class="line">        contentItem-&gt;<span class="built_in">setSmooth</span>(q-&gt;<span class="built_in">smooth</span>());</span><br><span class="line">        contentItem-&gt;<span class="built_in">setLive</span>(!q-&gt;<span class="built_in">flags</span>().<span class="built_in">testFlag</span>(WSurfaceItem::NonLive));</span><br><span class="line">        QObject::<span class="built_in">connect</span>(q, &amp;WSurfaceItem::smoothChanged, contentItem, &amp;WSurfaceItemContent::setSmooth);</span><br><span class="line">        newContentContainer.<span class="built_in">reset</span>(contentItem);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegateIsDirty) &#123;</span><br><span class="line">        <span class="keyword">auto</span> obj = delegate-&gt;<span class="built_in">createWithInitialProperties</span>(&#123;&#123;<span class="string">&quot;surface&quot;</span>, QVariant::<span class="built_in">fromValue</span>(q)&#125;&#125;, <span class="built_in">qmlContext</span>(q));</span><br><span class="line">        <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">            <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed on create surface item from delegate, error mssage:&quot;</span></span><br><span class="line">                       &lt;&lt; delegate-&gt;<span class="built_in">errorString</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delegateIsDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> contentItem = <span class="built_in">qobject_cast</span>&lt;QQuickItem*&gt;(obj);</span><br><span class="line">        <span class="keyword">if</span> (!contentItem)</span><br><span class="line">            <span class="built_in">qFatal</span>() &lt;&lt; <span class="string">&quot;SurfaceItem&#x27;s delegate must is Item&quot;</span>;</span><br><span class="line"></span><br><span class="line">        newContentContainer.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">QQuickItem</span>(q));</span><br><span class="line">        QQmlEngine::<span class="built_in">setObjectOwnership</span>(contentItem, QQmlEngine::CppOwnership);</span><br><span class="line">        contentItem-&gt;<span class="built_in">setParent</span>(newContentContainer.<span class="built_in">get</span>());</span><br><span class="line">        contentItem-&gt;<span class="built_in">setParentItem</span>(newContentContainer.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!newContentContainer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    newContentContainer-&gt;<span class="built_in">setZ</span>(<span class="built_in">qreal</span>(WSurfaceItem::ZOrder::ContentItem));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contentContainer) &#123;</span><br><span class="line">        newContentContainer-&gt;<span class="built_in">setPosition</span>(contentContainer-&gt;<span class="built_in">position</span>());</span><br><span class="line">        newContentContainer-&gt;<span class="built_in">setSize</span>(contentContainer-&gt;<span class="built_in">size</span>());</span><br><span class="line">        newContentContainer-&gt;<span class="built_in">setTransformOrigin</span>(contentContainer-&gt;<span class="built_in">transformOrigin</span>());</span><br><span class="line">        newContentContainer-&gt;<span class="built_in">setScale</span>(contentContainer-&gt;<span class="built_in">scale</span>());</span><br><span class="line"></span><br><span class="line">        contentContainer-&gt;<span class="built_in">disconnect</span>(q);</span><br><span class="line">        contentContainer-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    contentContainer = newContentContainer.<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">updateEventItem</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">updateBoundingRect</span>();</span><br><span class="line">    <span class="keyword">if</span> (eventItem)</span><br><span class="line">        <span class="built_in">updateEventItemGeometry</span>();</span><br><span class="line"></span><br><span class="line">    Q_EMIT q-&gt;<span class="built_in">contentItemChanged</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后当 <code>WSurfaceItem</code> 需要更新画面时，就能调用 <code>updatePaintNode</code> 更新渲染。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSGNode *<span class="title">WSurfaceItemContent::updatePaintNode</span><span class="params">(QSGNode *oldNode, UpdatePaintNodeData *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">W_D</span>(WSurfaceItemContent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tp = <span class="built_in">wTextureProvider</span>();</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;live || !tp-&gt;<span class="built_in">texture</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> texture = d-&gt;surface ? d-&gt;surface-&gt;<span class="built_in">handle</span>()-&gt;<span class="built_in">get_texture</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (texture) &#123;</span><br><span class="line">            tp-&gt;<span class="built_in">setTexture</span>(qw_texture::<span class="built_in">from</span>(texture), d-&gt;buffer.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tp-&gt;<span class="built_in">setBuffer</span>(d-&gt;buffer.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tp-&gt;<span class="built_in">texture</span>() || <span class="built_in">width</span>() &lt;= <span class="number">0</span> || <span class="built_in">height</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> oldNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> node = <span class="built_in">static_cast</span>&lt;QSGImageNode*&gt;(oldNode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Q_UNLIKELY</span>(!node)) &#123;</span><br><span class="line">        node = <span class="built_in">window</span>()-&gt;<span class="built_in">createImageNode</span>();</span><br><span class="line">        node-&gt;<span class="built_in">setOwnsTexture</span>(<span class="literal">false</span>);</span><br><span class="line">        QSGNode *fpnode = <span class="keyword">new</span> <span class="built_in">WSGRenderFootprintNode</span>(<span class="keyword">this</span>);</span><br><span class="line">        node-&gt;<span class="built_in">appendChildNode</span>(fpnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> texture = tp-&gt;<span class="built_in">texture</span>();</span><br><span class="line">    node-&gt;<span class="built_in">setTexture</span>(texture);</span><br><span class="line">    <span class="type">const</span> QRectF textureGeometry = d-&gt;bufferSourceBox;</span><br><span class="line">    node-&gt;<span class="built_in">setSourceRect</span>(textureGeometry);</span><br><span class="line">    <span class="function"><span class="type">const</span> QRectF <span class="title">targetGeometry</span><span class="params">(d-&gt;ignoreBufferOffset ? QPointF() : d-&gt;bufferOffset, size())</span></span>;</span><br><span class="line">    node-&gt;<span class="built_in">setRect</span>(targetGeometry);</span><br><span class="line">    node-&gt;<span class="built_in">setFiltering</span>(<span class="built_in">smooth</span>() ? QSGTexture::Linear : QSGTexture::Nearest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用 delegate 的目的是为了能让多个 <code>WSurfaceItem</code> 使用相同的窗口画面，例如某些场景需要临时创建一个窗口的分身，窗口切换列表、多任务视图等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSGTextureProvider *<span class="title">WSurfaceItemContent::textureProvider</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QQuickItem::<span class="built_in">isTextureProvider</span>())</span><br><span class="line">        <span class="keyword">return</span> QQuickItem::<span class="built_in">textureProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wTextureProvider</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">WSGTextureProvider *<span class="title">WSurfaceItemContent::wTextureProvider</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">W_DC</span>(WSurfaceItemContent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> w = <span class="built_in">qobject_cast</span>&lt;WOutputRenderWindow*&gt;(d-&gt;window);</span><br><span class="line">    <span class="keyword">if</span> (!w || !d-&gt;<span class="built_in">sceneGraphRenderContext</span>() || QThread::<span class="built_in">currentThread</span>() != d-&gt;<span class="built_in">sceneGraphRenderContext</span>()-&gt;<span class="built_in">thread</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;WQuickCursor::textureProvider: can only be queried on the rendering thread of an WOutputRenderWindow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;textureProvider) &#123;</span><br><span class="line">        d-&gt;textureProvider = <span class="keyword">new</span> <span class="built_in">WSGTextureProvider</span>(w);</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;surface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> texture = d-&gt;surface-&gt;<span class="built_in">handle</span>()-&gt;<span class="built_in">get_texture</span>()) &#123;</span><br><span class="line">                d-&gt;textureProvider-&gt;<span class="built_in">setTexture</span>(qw_texture::<span class="built_in">from</span>(texture), d-&gt;buffer.<span class="built_in">get</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d-&gt;textureProvider-&gt;<span class="built_in">setBuffer</span>(d-&gt;buffer.<span class="built_in">get</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d-&gt;textureProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Treeland 使用 <code>WQuickTextureProxy</code> 创建窗口的代理显示，而其中就是获取 <code>WSurfaceItem</code> 的 textureProvider。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSGTextureProvider *<span class="title">WQuickTextureProxy::textureProvider</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QQuickItem::<span class="built_in">isTextureProvider</span>())</span><br><span class="line">        <span class="keyword">return</span> QQuickItem::<span class="built_in">textureProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">W_DC</span>(WQuickTextureProxy);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;sourceItem)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d-&gt;sourceItem-&gt;<span class="built_in">textureProvider</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样多个 proxy 就可以显示同一个窗口的内容，比 QML 的 <code>ShaderEffectSource</code> 效率更高。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>上述仅仅是 Treeland 实现 Qt 和 wlroots 缝合的一部分流程，实际上对事件的处理就十分复杂，不止键盘输入，还需要处理光标、触控、触摸等其他设备。还有光标的绘制也需要区分硬光标和软光标，渲染画面时的硬件加速及软件实现等。</p>
<p>后续准备写一下光标相关的处理，以及还没介绍 Treeland 的画面是怎么绘制的。</p>
<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><aside>
💡

<p>Qt QPA <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qpa.html">https://doc.qt.io/qt-6/qpa.html</a><br>QOffscreenSurface <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qoffscreensurface.html">https://doc.qt.io/qt-6/qoffscreensurface.html</a></p>
</aside></article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src= "" data-lazy-src="/img/pwa/favicon.ico"></a><div class="post-copyright__author_name">小竹's blog</div><div class="post-copyright__author_desc">如何使用 QPA</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-twitter" target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fblog.justforlxz.com%2F2024%2F11%2F09%2Ftreeland-part1-how-to-implement-a-wlroots-based-compositor%2F&amp;text=Treeland%20Part.1%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%20wlroots%20%E7%9A%84%E5%90%88%E6%88%90%E5%99%A8" title="分享到Twitter"><i class="solitude fab fa-twitter"></i></a><div class="social-share-ico icon-qrcode" title="使用手机扫码阅读这篇文章"><i class="solitude fas fa-qrcode"></i><div class="share-main"><div class="share-main-all"><div id="qrcode"></div><div class="reward-dec">使用手机扫码阅读这篇文章</div></div></div><script pjax>typeof QRCode === 'function' && new QRCode(document.getElementById("qrcode"), {
    text: 'https://blog.justforlxz.com/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/',
    correctLevel : QRCode.CorrectLevel.L
});
window.addEventListener('DOMContentLoaded', () => {
    new QRCode(document.getElementById("qrcode"), {
        text: 'https://blog.justforlxz.com/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/',
        correctLevel : QRCode.CorrectLevel.L
    });
});
</script></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">小竹's blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Wayland-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>C++, Wayland, 图形学<span class="tagsPageCount">1</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/23/have-a-nice-day/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">异世相遇，尽享美味</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/01/treeland-go-go-go/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Treeland：DDE 进步的阶梯</div></div></a></div></nav><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude fa-solid fa-comment"></i><span> 评论</span><span class="count"> (<span class="giscus-count"></span>)</span></div></div><div class="comment-wrap"><div id="giscus-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/avatar.png"></div><div class="author-info__description_group"><div class="author-info__description">欲买桂花同载酒，终不似，少年游。</div><div class="author-info__description2">欢迎大家来到我的博客，我偶尔会写一些正经的技术文章。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">小竹</div><div class="author-info__desc">永远不要停止思考</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/justforlxz" title="Github"><i class="solitude  fab fa-github"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/693131" title="Bilibili"><i class="solitude  fab fa-bilibili"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://www.zhihu.com/people/justforlxz" title="Zhihu"><i class="solitude  fab fa-zhihu"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5"><span class="toc-text">名词概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Qt"><span class="toc-text">Qt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wlroots"><span class="toc-text">wlroots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#seat"><span class="toc-text">seat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RHI"><span class="toc-text">RHI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPA"><span class="toc-text">QPA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">基本工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-QPA"><span class="toc-text">Qt QPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">输入事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%8B%E4%BB%B6"><span class="toc-text">客户端事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E4%BF%A1%E6%81%AF"><span class="toc-text">屏幕信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-RHI"><span class="toc-text">Qt RHI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Viewport"><span class="toc-text">Qt Viewport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface-%E6%B8%B2%E6%9F%93"><span class="toc-text">Surface 渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-text">结尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3"><span class="toc-text">相关文档</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><a class="aside-list-item" href="/2024/12/27/vk-gl-cts-test-wayland/" title="使用 VK-GL-CTS 对 wayland 执行一致性测试"><div class="thumbnail"><img alt="使用 VK-GL-CTS 对 wayland 执行一致性测试" src="https://file.mkacg.com/misskey/files/6af33912-4d34-483a-b4f7-1c0dbfcaa07e.jpg"></div><div class="content"><span class="title" href="/2024/12/27/vk-gl-cts-test-wayland/" title="使用 VK-GL-CTS 对 wayland 执行一致性测试">使用 VK-GL-CTS 对 wayland 执行一致性测试</span><span class="article-recent_post_categories" href="/2024/12/27/vk-gl-cts-test-wayland/">技术分享</span></div></a><a class="aside-list-item" href="/2024/12/25/nix-home-manager/" title="Nix home-manager 使用笔记"><div class="thumbnail"><img alt="Nix home-manager 使用笔记" src="https://file.mkacg.com/misskey/files/d2ea8143-d911-4478-99e3-5359f75d437b.jpg"></div><div class="content"><span class="title" href="/2024/12/25/nix-home-manager/" title="Nix home-manager 使用笔记">Nix home-manager 使用笔记</span><span class="article-recent_post_categories" href="/2024/12/25/nix-home-manager/">技术分享</span></div></a><a class="aside-list-item" href="/2024/11/23/have-a-nice-day/" title="异世相遇，尽享美味"><div class="thumbnail"><img alt="异世相遇，尽享美味" src="/2024/11/23/have-a-nice-day/image.png"></div><div class="content"><span class="title" href="/2024/11/23/have-a-nice-day/" title="异世相遇，尽享美味">异世相遇，尽享美味</span><span class="article-recent_post_categories" href="/2024/11/23/have-a-nice-day/">心情随笔</span></div></a><a class="aside-list-item" href="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/" title="Treeland Part.1 如何实现一个基于 wlroots 的合成器"><div class="thumbnail"><img alt="Treeland Part.1 如何实现一个基于 wlroots 的合成器" src="https://file.mkacg.com/misskey/files/d78b4a0e-8dfe-493d-aa49-1f0741f115ec.png"></div><div class="content"><span class="title" href="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/" title="Treeland Part.1 如何实现一个基于 wlroots 的合成器">Treeland Part.1 如何实现一个基于 wlroots 的合成器</span><span class="article-recent_post_categories" href="/2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/">技术分享</span></div></a><a class="aside-list-item" href="/2024/11/01/treeland-go-go-go/" title="Treeland：DDE 进步的阶梯"><div class="thumbnail"><img alt="Treeland：DDE 进步的阶梯" src="https://file.mkacg.com/misskey/files/240f9f4e-a24d-41bc-84b9-e054092c7a60.jpg"></div><div class="content"><span class="title" href="/2024/11/01/treeland-go-go-go/" title="Treeland：DDE 进步的阶梯">Treeland：DDE 进步的阶梯</span><span class="article-recent_post_categories" href="/2024/11/01/treeland-go-go-go/">技术分享</span></div></a></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>竹子的碎碎念</span></div><div class="footer-bar-description"></div><a class="footer-bar-link" href="/about/"></a></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/justforlxz" title="Github"><i class="solitude  fab fa-github"></i></a><div class="nolazyload footer_mini_logo" id="footer_mini_logo" title="返回顶部" onclick="sco.toTop()"><img src alt="返回顶部"></div><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/693131" title="Bilibili"><i class="solitude  fab fa-bilibili"></i></a></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2016 - 2024 By&nbsp;<a class="footer-bar-link" href="/"><img class="author-avatar" src= "" data-lazy-src="/img/pwa/favicon.ico">小竹</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude fa-solid fa-arrows-rotate"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude fa-solid fa-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude fa-solid fa-clone"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude fa-solid fa-clipboard"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude fa-solid fa-comment-medical"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude fa-regular fa-window-maximize"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude fa-solid fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude fa-solid fa-clone"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude fa-solid fa-cloud-arrow-down"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude fa-solid fa-magnifying-glass"></i><span>站内搜索</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=2.1.15"></script><script src="/js/main.js?v=2.1.15"></script><script src="/js/third_party/waterfall.min.js?v=2.1.15"></script><script src="https://fastly.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="https://fastly.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script><script src="/js/third_party/universe.min.js?v=2.1.15"></script><script>dark()
</script><script src="/js/tw_cn.js?v=2.1.15"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="https://fastly.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://fastly.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="https://fastly.jsdelivr.net/npm/colorthief@2.6.0/dist/color-thief.min.js"></script><script src="/js/covercolor/local.js?v=2.1.15"></script><script>window.paceOptions = {
  restartOnPushState: false
}

utils.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')
</script><script src="https://fastly.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script src="/js/right_menu.js?v=2.1.15"></script><div class="js-pjax"><script>(()=>{
    const getGiscusTheme = theme => {
        return theme === 'dark' ? 'dark' : 'light'
    }

    const loadGiscus = () => {
        const config = Object.assign({
            src: 'https://giscus.app/client.js',
            'data-repo': 'justforlxz/blog-comment',
            'data-repo-id': 'R_kgDONG_Evg',
            'data-category-id': 'DIC_kwDONG_Evs4Cjwkl',
            'data-mapping': 'pathname',
            'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
            'data-reactions-enabled': '1',
            crossorigin: 'anonymous',
            async: true
        },null)

        const ele = document.createElement('script')
        for (let key in config) {
            ele.setAttribute(key, config[key])
        }
        document.getElementById('giscus-wrap').appendChild(ele)
    }

    const changeGiscusTheme = theme => {
        const sendMessage = message => {
            const iframe = document.querySelector('iframe.giscus-frame')
            if (!iframe) return
            iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
        }

        sendMessage({
            setConfig: {
                theme: getGiscusTheme(theme)
            }
        });
    }

    utils.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

    if ('Giscus' === 'Giscus' || !true) {
        if (true) {
            const giscusWrap = document.getElementById('giscus-wrap')
            if (giscusWrap) {
                utils.loadComment(giscusWrap, loadGiscus)
            }
        } else {
            loadGiscus()
        }
    } else {
        window.loadTwoComment = loadGiscus
    }
})()</script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ["title","#body-wrap","#site-config","meta[name=\"description\"]",".js-pjax","meta[property^=\"og:\"]","#config-diff",".rs_show",".rs_hide"],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude fa-solid fa-xmark"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=2.1.15"></script><!-- Tianli-Talk--><!-- music--></body></html>
        <script>
            const posts = ["2024/12/27/vk-gl-cts-test-wayland/","2024/12/25/nix-home-manager/","2024/11/23/have-a-nice-day/","2024/11/09/treeland-part1-how-to-implement-a-wlroots-based-compositor/","2024/11/01/treeland-go-go-go/","2024/04/15/Add-macvlan-net/","2024/03/01/solved-run-k8s-in-wsl2/","2023/09/11/solved-Could-not-find-a-declaration-file-for-module-vuex/","2023/06/29/solved-react-native-error-SDK-iphoneos-cannot-be-located/","2023/06/25/How-to-develop-a-kwin-special-effects-plugin/","2023/05/24/How-to-count-the-cpu-usage-of-a-process/","2023/04/19/How-to-Solve-the-Module-not-found-Cannot-resolve-fs-error-in-Next-js/","2023/04/17/Kitty-configuration-for-macOS/","2023/04/11/How-to-solve-parallels-desktop-linux-usb-problem/","2023/03/15/How-to-remove-all-Terminating-pods/","2023/02/01/solved-duplicate-hostname-or-contents/","2022/12/08/how-to-use-nvim-dap-to-debug-cpp/","2022/11/07/photo-1-init-project/","2022/08/25/docker-buildx-multi-arch-images/","2022/07/21/meet-unity-shader/","2022/07/02/jsx/","2022/06/24/stack-problem/","2022/04/26/an-evil-idea/","2022/04/09/hello-metal-5/","2022/04/04/hello-metal-4/","2022/04/04/hello-metal-3/","2022/04/04/hello-metal-2/","2022/04/04/hello-metal-1/","2022/03/22/vim简单配置/","2022/03/16/css-mastering-margin-collapsing/","2022/03/10/if-constexpr/","2022/03/08/latex-environment-config/","2022/03/04/qdir-stdfilesystem/","2022/02/25/How-to-use-cuda-with-deepin/","2022/01/05/fix-h5py-build-failed-on-m1/","2021/12/29/Starting-sessions-with-systemd-part-2/","2021/12/25/Starting-sessions-with-systemd/","2021/09/14/introduction-to-the-qml-cmake-api/","2021/08/10/Vuex基本使用/","2021/08/07/CSS浮动笔记/","2021/08/07/JavaScript任务执行笔记/","2021/07/24/wayland-architecture/","2021/07/24/wayland-types/","2021/07/24/wayland-introduction/","2021/07/24/wayland-preface/","2021/07/06/container-with-most-water/","2021/07/06/two-sum/","2021/07/06/binary-search/","2021/03/04/package-manager-for-arch/","2021/02/27/timemachine/","2021/02/27/samba/","2021/02/26/2020review/","2020/12/23/ccls/","2020/11/17/qt-multi-thread/","2020/09/17/deepin-wine-chinese-problem/","2020/09/08/use-refind-to-boot-system/","2020/09/06/deepin-git-version/","2020/09/03/use-vscode-to-remotely-develop-dde/","2020/08/06/develop-startdde-on-archlinux/","2020/07/27/use-github-action-to-check-dde-launcher/","2020/07/21/use-perf-to-analytics-program/","2020/06/16/CTest & QTEST/","2020/06/15/CPP项目的一些坑/","2020/06/15/使用inquirer提供交互式git-commit/","2020/06/01/vue-router路由复用后页面没有刷新/","2020/05/31/vue3-upgrade/","2020/02/01/JavaScript建造者模式/","2020/01/31/浅谈Javascript构造器模式/","2020/01/01/2019review/","2020/01/01/使用伪元素创建一个圆点/","2019/12/26/use-serial-port-debug-deepin-on-archlinux/","2019/12/26/cpp-sort/","2019/12/09/记录一个坑爹的usb网卡/","2019/12/09/use-github-actions-to-depoly-hexo/","2019/12/08/vue-component-props/","2019/12/08/vue-transitions/","2019/11/25/使用webpack-dev-server来监听项目变化/","2019/10/24/给Archlinux开启BFQ和MuQSS/","2019/10/22/使用webpack打包Vue和TypeScript/","2019/10/14/webpack入门/","2019/06/16/wsl2的使用体验/","2019/06/15/入坑typescript了/","2019/05/23/CMake-CTests-for-dde-control-center/","2019/02/21/how-to-use-LNMP-on-deepin/","2019/01/23/fuck-taobao/","2018/12/12/hibernate-for-swapfile/","2018/11/11/quick-sort-for-cpp/","2018/11/09/use-google-calendar-to-finishe-work/","2018/11/09/hexo page move to coding/","2018/08/29/cpp-smart-pointer/","2018/07/14/卷积神经网络简述/","2018/07/14/深度学习笔记/","2018/07/09/C-plus-plus-Iterator-笔记/","2018/06/28/在DeepinLinux下使用nVidia-CUDA/","2018/06/25/deepin待机后键盘和触摸板无法使用的解决方法/","2018/06/05/dreamscene插件开发/","2018/05/23/Dock插件开发/","2018/04/01/Linux的PAM是什么/","2018/03/11/重构dde-session-ui/","2018/01/12/使用DTK开发/","2017/12/25/解决IntelliJ-IDEA界面瞎眼/","2017/12/18/修复Archlinux的Grub/","2017/09/01/解决NVIDIA重新启动以后系统冻结/","2017/08/31/我的代理折腾方案/","2017/08/23/开发topbar中的技术问题/","2017/08/20/TKL主题优化-转/","2017/08/16/debug了两天，只删了一行代码/","2017/08/15/正常的流程在界面上却是bug/","2017/08/11/在deepin上使用dnsmasq来解决dns解析缓慢/","2017/07/24/PPA/","2017/07/20/topbar-PPA/","2017/07/14/webhook/","2017/07/04/SAOUTILS/","2017/06/26/Topbar/","2016/07/15/ArchLinux运行steam出现缺少LibGL-steam-libGL-error-failed-to-load-driver-swrast/","2016/07/15/docker-hexo/","2016/05/31/docker-aria2c/","2016/05/25/aria2配置/","2016/04/10/linux下安装vmware及archlinux的安装和配置/","2016/04/08/font-config/","2016/03/25/my-life/","2016/03/25/page/"];
            function toRandomPost() {
                const randomPost = posts[Math.floor(Math.random() * posts.length)];
                pjax.loadUrl(GLOBAL_CONFIG.root + randomPost);
            }
        </script>